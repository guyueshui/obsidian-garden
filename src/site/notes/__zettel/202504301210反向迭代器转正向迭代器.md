---
{"dg-publish":true,"permalink":"/zettel/202504301210/","title":202504301210,"tags":["iterator","reverse_iterator"],"created":"2025-04-30T12:10:32+08:00"}
---

反向迭代器有一个坑点。正向迭代器，指向的位置和解引用对应的元素是一致的；反向迭代器指向的位置和解引用对应的元素差了一个。从前往后看（正向角度），反向迭代器指向位置i，那么解引用会得到i-1位置上的元素。

[cpprefrence](https://en.cppreference.com/w/cpp/iterator/reverse_iterator)指出，

> For a reverse iterator `r` constructed from an iterator `i`, the relationship `&*r == &*(i - 1)` is always true (as long as `r` is [dereferenceable](https://en.cppreference.com/w/cpp/iterator#Dereferenceability_and_validity "cpp/iterator")); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.

![](https://upload.cppreference.com/mwiki/images/3/39/range-rbegin-rend.svg)


==This is due to the fact that a reverse iterator has a slightly different referencing logic than a regular iterator: it points to an element, but when dereferenced, it yields a reference to the previous element.==

![](/img/user/assets/image-20250430.121816.913.png)

更多参考：

- [c++ - Why does removing the _first_ element of a list invalidate `.rend()`? - Stack Overflow](https://stackoverflow.com/questions/14760134/why-does-removing-the-first-element-of-a-list-invalidate-rend/14760316#14760316)
- [c++ - Why can I not convert a reverse iterator to a forward iterator? - Stack Overflow](https://stackoverflow.com/questions/4407985/why-can-i-not-convert-a-reverse-iterator-to-a-forward-iterator/4408182)
- [c++ - Can I convert a reverse iterator to a forward iterator? - Stack Overflow](https://stackoverflow.com/questions/2037867/can-i-convert-a-reverse-iterator-to-a-forward-iterator)

反向迭代器的`base`成员函数，返回底层所持有的正向迭代器，我们转正向迭代器的时候尤其要注意上面的坑点，

```cpp
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>

int main() { 
    int i[] = {1,2,3,4,5,6};
    std::vector<int> v(i, i+6);

    auto ri = std::find(std::rbegin(v), std::rend(v), 3);
    std::cout << *ri << std::endl; // 3
    auto fi = ri.base()-1;
    std::cout << *fi << std::endl; // 3
    fi = (++ri).base();
    std::cout << *fi << std::endl; // 3
}
```

即，

- 要么调用base之前将反向迭代器增一
- 要么调用base之后将得到的正向迭代器减一